다음은 현재 기획된 **윈도우 UI 시스템**의 정리된 설계 문서야. 

---

# 🛠 **Aera UI 시스템 설계 (TypeScript + Vite)**  
👉 **모든 Area은 `div` 요소로만 구성되며, `border` 조작을 통해 크기 조절, 분할, 합치기를 구현한다.**  

## **1. 영역(Area)과 경계선(Border) 구조**  
### ✅ **기본 구조**  
- 각 Area는 **고유 ID를 가진 `div` 요소** (예: abcdefgh12345678)
- Area안에는 **4방향의 모서리에 경계선(Border)** 배치
- ID형식 : 16자리 랜덤 문자열 (예: abcdefgh12345678)
- vwpx : 1.00vw의 모니터 px값
- vhpx : 1.00vh의 모니터 px값

### ✅ **역할별 요소**  
| 요소 | 설명 |
|------|------|
| **영역(Area)** | `div` 요소로 생성, 일단은 개발 중이니 CSS에서 보더만 보이게 하자 |
| **경계선 (Border)** | 수직/수평으로 구분하여 영역의 안쪽 모서리에 배치 |

### ✅ **Area 속성**  
| 속성 | 설명 |
|------|------|
| **id** | 해당 Area의 고유 ID |
| **x** | 해당 Area의 X좌표 |
| **y** | 해당 Area의 Y좌표 |
| **width** | 해당 Area의 너비 |
| **height** | 해당 Area의 높이 |
| **temp_x** | 크기 조절 시 임시로 적용되는 X좌표 |
| **temp_y** | 크기 조절 시 임시로 적용되는 Y좌표 |
| **temp_width** | 크기 조절 시 임시로 적용되는 너비 |
| **temp_height** | 크기 조절 시 임시로 적용되는 높이 |
| **is_resizable** | Area가 크기 조절 가능한지 여부 |
| **is_splitable** | Area가 분할 가능한지 여부 |
| **is_joinable** | Area가 합치기 가능한지 여부 |
### 참고
- x, y는 이 Area의 왼쪽상단의 좌표이다.
- 좌표값, 크기값은 0.00 ~ 100.00 사이의 값이다.
- 해당 값은 vw, vh 단위로 변환하여 css로 적용된다.
- 글로벌 변수에 vwpx, vhpx 값이 저장되어 있고, 각각 1.00vw, 1.00vh의 px값이다.
- temp_x, temp_y, temp_width, temp_height는 크기 조절 시 임시로 적용되는 값으로, 크기 변경 중에 취소하는 경우 이 값을 삭제하는 것으로 구현한다. 크기 조절을 완료하면 이 값을 x, y, width, height에 적용한다.
- `workState`는 현재 작업 상태를 나타내는 변수로, 크기 조절 중인지, 분할 중인지, 합치기 중인지 등을 나타낸다.

### ✅ **Border 속성**  
| 속성 | 설명 |
|------|------|
| **id** | 해당 Border의 고유 ID |
| **direction** | 해당 Border의 방향. Vertical또는 Horizontal의 값을 가진다. |
| **x** | 해당 Border의 X좌표 |
| **y** | 해당 Border의 Y좌표 |
| **size** | 해당 Border의 크기(자세한 건 *참고*에) |
| **temp_x** | 크기 조절 시 임시로 적용되는 X좌표 |
| **temp_y** | 크기 조절 시 임시로 적용되는 Y좌표 |
| **size** | 크기 조절 시 임시로 적용되는 크기 |
| **area_a** | 인접한 area a |
| **area_b** | 인접한 area b |
| **main** | 주체가 되는 인접한 영역 (a 또는 b의 값을 가짐) |
| **sub** | 주체가 아닌 인접한 영역 (a 또는 b의 값을 가짐) |
### 참고
- 전역으로 선언된 `border_thickness_size` 값에 경계선의 두께가 저장되며, 이 값은 px 단위이다.
- Border의 두께(가로선인 경우 너비, 세로선인 경우 높이 크기)는 `border_thickness_size` 값을 vwpx, vhpx를 사용해 변환하여 적용한다.
- direction이 Vertical인 경우 size는 높이를 나타내며, Horizontal인 경우 너비를 나타낸다.
- temp_x, temp_y, temp_size는 크기 조절 시 임시로 적용되는 값으로, 크기 변경 중에 취소하는 경우 이 값을 삭제하는 것으로 구현한다. 크기 조절을 완료하면 이 값을 x, y, size에 더하고 삭제한다.

---

## **2. 영역 크기 조절 (Resizable Borders)**  
### ✅ **동작 방식**  
1. **마우스가 경계선 위에 올라가면 커서 변경 (세로선:`↔` / 가로선:`↕`)**  
2. **이 상태에서 드래그하면 인접한 두 윈도우의 크기 조정**

### ✅ **크기 조절 매커니즘**  
1. 마우스가 경계선에 닿은 상태에서 드래그를 시작하면
    - `is_resizable` 값이 true라면 크기 조절 가능, 다음 코드 실행
    - 현재 상태 `workState`가 조절 가능한 상태(`none`)인 경우 다음 코드 실행
    - 현재 상태 `workState`를 `area resize mode`로 변경
    - 이 경계선을 반으로 나눴을 때(세로선이면 세로로, 가로선이면 가로로), 마우스 포인터가 어느 영역에 있는지 파악해서 `main`속성에 저장하기
2. 세로선인지 가로선인지 파악해서 드래그 방향 파악
3. 인접한 영역의 크기를 가로 또는 세로 방향으로 마우스가 드래그한 px거리만큼 조정함
4. 만약 지금 드래그 되고 있는 경계선과 같은 선 상에 있는 경계선(가로 경계선일 때 같은 Y좌표를 가진, 세로일 때는 같은 X좌표를 지닌)이 있다면 같이 이동시키기
4. 드래그 종료 시
    - `workState`를 `none`으로 변경
    - `x`, `y`, `size`값에 `temp_x`, `temp_y`, `temp_size`값을 +=로 적용
    - `temp_x`, `temp_y`, `temp_size`값을 삭제

---

## **3. 영역 분할 (Split Area)**
### ✅ **가능한 동작 방식**
1. **우클릭 메뉴에서 ‘Vertical Split’ / ‘Horizontal Split’ 선택, 또는 `Alt + 모서리를 창 내부로 드래그`하기**  
2. **우클릭 메뉴로 분할을 하면, 선택된 방향에 따라 main 창의 크기가 절반이 되고, 새로운 창이 빈 공간에 들어옴** 
3. **드래그로 분할이 시작되면 마우스 포인터 위치에서 새 창이 생성되며, 이후는 크기 조절과 같음** 

### ✅ **분할 과정**
일단 경계선 내의 마우스 포인터의 위치에 따라 main과 sub 영역을 찾아 저장해둔다.
1. `우클릭 → Vertical / Horizontal Split` 선택하는 경우(우클릭이 시작된 위치에 기반해 main과 sub 영역을 찾아야 함)
    1. 인접한 main area의 `is_splitable`이 true라면 다음 코드를 실행
    2. main 영역의 크기를 방향에 맞춰서(vertical이라면 세로로 자르기, horizontal이면 가로로 자르기) 절반으로 줄이고, 새로운 영역을 빈 공간에 맞춰서 생성하기.
    3. 새 영역에 적절하게 경계선을 추가하기
2. `Ctrl + 모서리를 영역 내부로 드래그`하는 경우
    1. 드래그 시작 시, 마우스 포인터 위치에 새로운 영역을 생성하기
    2. 이후는 크기 조절과 같은 방식으로 진행하기

---

## **4. 영역 합치기 (Join Area)**  
### ✅ **동작 방식**  
- **우클릭 메뉴에서 "Join Up/Down/Left/Right" 선택 → 해당 방향의 윈도우와 합침**  
- **모서리를 Ctrl + 영역 외부로 드래그하여 인접한 영역과 병합 가능**  
- **합쳐진 후, 하나의 영역은 제거되고 나머지 영역은 확장됨**  

### ✅ **합치기 과정**  
1. `우클릭 → Join Up/Down/Left/Right` 선택  
2. **해당 방향의 main, sub 영역 감지 후 병합**  
3. 기존 경계선(Border) 제거
### ✅ **모서리 드래그로 합치기**  
1. 모서리를 **Ctrl + 윈도우 밖으로 드래그**  
2. 드래그 방향에 따라 합칠 main, sub 영역 탐색  
3. 윈도우 병합 후 기존 경계선 제거 

---

## **5. 마우스 이벤트 및 동작 감지**  
### ✅ **드래그 이벤트 감지 방식**  
- **경계선에서 드래그 시작** → 크기 조절  
- **경계선에서 Ctrl + 영역 내부로 드래그 시작** → 새로운 영역 추가(분할)
- **경계선에서 Ctrl + 영역 외부로 드래그 시작** → 합차기

### ✅ **드래그 종료 후 동작 결과**  
| 마우스 위치 | 동작 |
|------------|------|
| 기존 윈도우 내부 | 분할 |
| 기존 윈도우 외부 | 합치기 |

---

## **🚀 전체 구현 흐름**  
1. **최초 사이트 실행 시 화면 전체에 차 있는 영역 및 4방향의 경계선 구조 생성**  
3. **우클릭 메뉴에서 윈도우 분할/합치기**
2. **모서리 드래그 시 → 크기 조절**
4. **ctrl + 모서리 드래그 시 방향에 따라 분할/합치기 구분**  
5. **드래그 종료 시 변경 사항(temp_~) 적용하기**

---

이제 이 설계를 바탕으로 개발을 진행하면 될 거야! 🚀